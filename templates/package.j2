package {{ args.name }};

# This file is automatically generated by plbindgen.
# Changes to this file will be lost if it is regenerated.

use FFI::Platypus 2.00;
use FFI::Platypus::Lang::C;
use FFI::Platypus::Lang::Rust;
use FFI::CheckLib qw( find_lib_or_die );
use File::Basename qw( dirname );
use Exporter qw( import );

our @EXPORT = qw( );
our %EXPORT_TAGS = ( all => \@EXPORT );

BEGIN {
    # FIXME: FFI::Platypus::Lang::Rust doesn't have enum.
    my $c_map = FFI::Platypus::Lang::C->native_type_map;
    my $rust_map = FFI::Platypus::Lang::Rust->native_type_map;
    $rust_map->{$_} = $c_map->{$_} for 'enum', 'senum';
    *FFI::Platypus::Lang::Rust::native_type_map = sub { $rust_map };
}

our $VERSION = {{ cargo.package.version | perl_quote }};

my $ffi = FFI::Platypus->new( api => 2, lang => 'Rust' );
$ffi->bundle;

{% for enum in lib.enums %}
$ffi->type({{ enum.repr }} => {{ enum.name | perl_quote }});
{% set constants = enum.variants | map(attribute='name') | map('perl_quote') | join(', ') %}
{% for variant in enum.variants -%}
use constant {{ variant.name }} => {{ variant.value }};
{% endfor -%}
push @{ $EXPORT_TAGS{all} }, {{ constants }};
{% endfor %}

{% for opaque in lib.opaques -%}
$ffi->type(opaque => {{ opaque.name | perl_quote }});
{% endfor %}

{% for record in lib.records -%}
use {{ args.name }}::{{ record.name }};

{{ args.name }}::{{ record.name }}->init_record_layout($ffi);
$ffi->type("record({{ args.name }}::{{ record.name }})" => '{{ record.name }}');
{% endfor %}

{% for fun in lib.exports -%}
$ffi->attach( {{ fun.name }} => [{{ fun.args | map('perl_quote') | join(', ') }}] => {{ fun.ret | perl_quote }} );
{% endfor %}

{% set functions = lib.exports | map(attribute='name') | map('perl_quote') | join(', ') %}
push @{ $EXPORT_TAGS{all} }, {{ functions }};

1; 